# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

type AnswerMutationPayload {
    answer: AnswerNode
    clientMutationId: String
    errors: [ErrorType]
}

type AnswerNode {
    checkQueue: Int!
    hardLevelOfAnswer: AnswerHardLevelOfAnswer!
    helpTextv1: String
    helpTextv2: String
    helpTextv3: String
    id: ID!
    isDeleted: Boolean!
    isInvisible: Boolean!
    isRequired: Boolean!
    isTrue: Boolean!
    question: QuestionNode!
    text: String!
    videoUrl: String
}

"""

Archive account and revoke refresh tokens.

User must be verified and confirm password.
"""
type ArchiveAccount {
    errors: ExpectedErrorType
    success: Boolean
}

type CardAuthorMutationPayload {
    cardAuthor: CardAuthorNode
    clientMutationId: String
    errors: [ErrorType]
}

type CardAuthorNode {
    cardSet: [CardNode!]!
    id: ID!
    name: String!
}

type CardCourseNode {
    courseData: GenericScalar
    id: ID!
    name: String
}

type CardMutationPayload {
    card: CardNode
    clientMutationId: String
    errors: [ErrorType]
}

type CardNode {
    additionalText: String
    author: [CardAuthorNode!]!
    cardContentType: CardCardContentType!
    id: ID!
    isCardUseAdditionalText: Boolean!
    isCardUseMainContent: Boolean!
    isCardUseMainText: Boolean!
    isCardUseTestBeforeCard: Boolean!
    isCardUseTestInCard: Boolean!
    siteUrl: String
    subTheme: [CardSubThemeNode!]!
    testBeforeCard: QuestionNode
    testInCard: QuestionNode
    text: String
    title: String!
    videoUrl: String
}

type CardSubThemeMutationPayload {
    cardSubTheme: CardSubThemeNode
    clientMutationId: String
    errors: [ErrorType]
}

type CardSubThemeNode {
    cardSet: [CardNode!]!
    id: ID!
    name: String!
    theme: CardThemeNode
}

type CardThemeMutationPayload {
    cardTheme: CardThemeNode
    clientMutationId: String
    errors: [ErrorType]
}

type CardThemeNode {
    cardsubthemeSet: [CardSubThemeNode!]!
    globalTheme: GlobalCardThemeNode
    id: ID!
    name: String!
}

type CreateCardCoursePayload {
    clientMutationId: String
    course: CardCourseNode
}

type CreateDetailQuestionStatisticPayload {
    clientMutationId: String
    detailStatistic: DetailQuestionStatisticNode
}

type CreateQuestionSequencePayload {
    clientMutationId: String
    sequence: QuestionSequenceNode
}

"""

Delete account permanently or make `user.is_active=False`.

The behavior is defined on settings.
Anyway user refresh tokens are revoked.

User must be verified and confirm password.
"""
type DeleteAccount {
    errors: ExpectedErrorType
    success: Boolean
}

type DetailQuestionStatisticNode {
    id: ID!
    isLogin: Boolean!
    question: QuestionNode
    statistic: GenericScalar
    userName: String
}

type ErrorType {
    field: String!
    messages: [String!]!
}

type GlobalCardThemeMutationPayload {
    clientMutationId: String
    errors: [ErrorType]
    globalCardTheme: GlobalCardThemeNode
}

type GlobalCardThemeNode {
    cardthemeSet: [CardThemeNode!]!
    id: ID!
    name: String!
}

type Mutation {
    """

    Archive account and revoke refresh tokens.

    User must be verified and confirm password.
    """
    archiveAccount(password: String!): ArchiveAccount
    card(input: CardMutationInput!): CardMutationPayload
    cardAuthor(input: CardAuthorMutationInput!): CardAuthorMutationPayload
    cardSubTheme(input: CardSubThemeMutationInput!): CardSubThemeMutationPayload
    cardTheme(input: CardThemeMutationInput!): CardThemeMutationPayload
    createAnswer(input: AnswerMutationInput!): AnswerMutationPayload
    createCardCourse(input: CreateCardCourseInput!): CreateCardCoursePayload
    createDetailQuestionStatistic(input: CreateDetailQuestionStatisticInput!): CreateDetailQuestionStatisticPayload
    createQuestion(input: QuestionMutationInput!): QuestionMutationPayload
    createQuestionAuthor(input: QuestionAuthorMutationInput!): QuestionAuthorMutationPayload
    createQuestionSequence(input: CreateQuestionSequenceInput!): CreateQuestionSequencePayload
    createQuestionThemes(input: QuestionThemesMutationInput!): QuestionThemesMutationPayload
    """

    Delete account permanently or make `user.is_active=False`.

    The behavior is defined on settings.
    Anyway user refresh tokens are revoked.

    User must be verified and confirm password.
    """
    deleteAccount(password: String!): DeleteAccount
    globalCardTheme(input: GlobalCardThemeMutationInput!): GlobalCardThemeMutationPayload
    """

    Change account password when user knows the old password.

    A new token and refresh token are sent. User must be verified.
    """
    passwordChange(newPassword1: String!, newPassword2: String!, oldPassword: String!): PasswordChange
    """

    Change user password without old password.

    Receive the token that was sent by email.

    If token and new passwords are valid, update
    user password and in case of using refresh
    tokens, revoke all of them.

    Also, if user has not been verified yet, verify it.
    """
    passwordReset(newPassword1: String!, newPassword2: String!, token: String!): PasswordReset
    """

    Set user password - for passwordless registration

    Receive the token that was sent by email.

    If token and new passwords are valid, set
    user password and in case of using refresh
    tokens, revoke all of them.

    Also, if user has not been verified yet, verify it.
    """
    passwordSet(newPassword1: String!, newPassword2: String!, token: String!): PasswordSet
    "Same as `grapgql_jwt` implementation, with standard output."
    refreshToken(refreshToken: String!): RefreshToken
    """

    Register user with fields defined in the settings.

    If the email field of the user model is part of the
    registration fields (default), check if there is
    no user with that email or as a secondary email.

    If it exists, it does not register the user,
    even if the email field is not defined as unique
    (default of the default django user model).

    When creating the user, it also creates a `UserStatus`
    related to that user, making it possible to track
    if the user is archived, verified and has a secondary
    email.

    Send account verification email.

    If allowed to not verified users login, return token.
    """
    register(email: String!, password1: String!, password2: String!, username: String!): Register
    """

    Sends activation email.

    It is called resend because theoretically
    the first activation email was sent when
    the user registered.

    If there is no user with the requested email,
    a successful response is returned.
    """
    resendActivationEmail(email: String!): ResendActivationEmail
    "Same as `grapgql_jwt` implementation, with standard output."
    revokeToken(refreshToken: String!): RevokeToken
    """

    Send password reset email.

    For non verified users, send an activation
    email instead.

    Accepts both primary and secondary email.

    If there is no user with the requested email,
    a successful response is returned.
    """
    sendPasswordResetEmail(email: String!): SendPasswordResetEmail
    """

    Send activation to secondary email.

    User must be verified and confirm password.
    """
    sendSecondaryEmailActivation(email: String!, password: String!): SendSecondaryEmailActivation
    statistic(input: StatisticMutationInput!): StatisticMutationPayload
    """

    Swap between primary and secondary emails.

    Require password confirmation.
    """
    swapEmails(password: String!): SwapEmails
    """

    Obtain JSON web token for given user.

    Allow to perform login with different fields,
    and secondary email if set. The fields are
    defined on settings.

    Not verified users can login by default. This
    can be changes on settings.

    If user is archived, make it unarchive and
    return `unarchiving=True` on output.
    """
    tokenAuth(email: String, password: String!, username: String): ObtainJSONWebToken
    """

    Update user model fields, defined on settings.

    User must be verified.
    """
    updateAccount(firstName: String, lastName: String): UpdateAccount
    updateAnswer(input: AnswerMutationInput!): AnswerMutationPayload
    updateCardCourse(input: UpdateCardCourseInput!): UpdateCardCoursePayload
    updateQuestion(input: QuestionMutationInput!): QuestionMutationPayload
    updateQuestionAuthor(input: QuestionAuthorMutationInput!): QuestionAuthorMutationPayload
    updateQuestionSequence(input: UpdateQuestionSequenceInput!): UpdateQuestionSequencePayload
    updateQuestionThemes(input: QuestionThemesMutationInput!): QuestionThemesMutationPayload
    """

    Verify user account.

    Receive the token that was sent by email.
    If the token is valid, make the user verified
    by making the `user.status.verified` field true.
    """
    verifyAccount(token: String!): VerifyAccount
    """

    Verify user secondary email.

    Receive the token that was sent by email.
    User is already verified when using this mutation.

    If the token is valid, add the secondary email
    to `user.status.secondary_email` field.

    Note that until the secondary email is verified,
    it has not been saved anywhere beyond the token,
    so it can still be used to create a new account.
    After being verified, it will no longer be available.
    """
    verifySecondaryEmail(token: String!): VerifySecondaryEmail
    "Same as `grapgql_jwt` implementation, with standard output."
    verifyToken(token: String!): VerifyToken
}

"""

Obtain JSON web token for given user.

Allow to perform login with different fields,
and secondary email if set. The fields are
defined on settings.

Not verified users can login by default. This
can be changes on settings.

If user is archived, make it unarchive and
return `unarchiving=True` on output.
"""
type ObtainJSONWebToken {
    errors: ExpectedErrorType
    refreshToken: String
    success: Boolean
    token: String
    unarchiving: Boolean
    user: UserNode
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"""

Change account password when user knows the old password.

A new token and refresh token are sent. User must be verified.
"""
type PasswordChange {
    errors: ExpectedErrorType
    refreshToken: String
    success: Boolean
    token: String
}

"""

Change user password without old password.

Receive the token that was sent by email.

If token and new passwords are valid, update
user password and in case of using refresh
tokens, revoke all of them.

Also, if user has not been verified yet, verify it.
"""
type PasswordReset {
    errors: ExpectedErrorType
    success: Boolean
}

"""

Set user password - for passwordless registration

Receive the token that was sent by email.

If token and new passwords are valid, set
user password and in case of using refresh
tokens, revoke all of them.

Also, if user has not been verified yet, verify it.
"""
type PasswordSet {
    errors: ExpectedErrorType
    success: Boolean
}

type Query {
    answer: [AnswerNode]
    answersInRandomPositions: [AnswerNode]
    card: [CardNode]
    cardAuthor: [CardAuthorNode]
    cardById(id: ID): CardNode
    cardCourse: [CardCourseNode]
    cardCourseById(id: ID): CardCourseNode
    cardGlobalTheme: [GlobalCardThemeNode]
    cardSubTheme: [CardSubThemeNode]
    cardTheme: [CardThemeNode]
    detailQuestionStatistic: [DetailQuestionStatisticNode]
    detailQuestionStatisticByQuestionId(id: ID): [DetailQuestionStatisticNode]
    me: UserNode
    question: [QuestionNode]
    questionAuthor: [QuestionAuthorNode]
    questionById(id: ID): QuestionNode
    questionSequence: [QuestionSequenceNode]
    questionSequenceById(id: ID): QuestionSequenceNode
    questionThemes: [QuestionThemesNode]
    "The ID of the object"
    user(id: ID!): UserNode
    users(after: String, before: String, email: String, first: Int, isActive: Boolean, last: Int, offset: Int, status_Archived: Boolean, status_SecondaryEmail: String, status_Verified: Boolean, username: String, username_Icontains: String, username_Istartswith: String): UserNodeConnection
}

type QuestionAuthorMutationPayload {
    clientMutationId: String
    errors: [ErrorType]
    questionAuthor: QuestionAuthorNode
}

type QuestionAuthorNode {
    id: ID!
    name: String!
    questionAuthors: [QuestionNode!]!
}

type QuestionMutationPayload {
    clientMutationId: String
    errors: [ErrorType]
    question: QuestionNode
}

type QuestionNode {
    answers: [AnswerNode!]!
    author: [QuestionAuthorNode!]!
    cardTestBeforeCardSet: [CardNode!]!
    cardTestInCardSet: [CardNode!]!
    detailquestionstatisticSet: [DetailQuestionStatisticNode!]!
    id: ID!
    isImageQuestion: Boolean!
    numberOfShowingAnswers: Int!
    questionstatistic: QuestionStatisticNode
    text: String!
    theme: [QuestionThemesNode!]!
    videoUrl: String
}

type QuestionSequenceNode {
    description: String
    id: ID!
    name: String
    sequenceData: GenericScalar
}

type QuestionStatisticNode {
    id: ID!
    numberOfPasses: Int!
    question: QuestionNode
    sumOfAllAttempts: Int!
}

type QuestionThemesMutationPayload {
    clientMutationId: String
    errors: [ErrorType]
    questionThemes: QuestionThemesNode
}

type QuestionThemesNode {
    description: String
    id: ID!
    name: String!
    questionThemes: [QuestionNode!]!
}

"Same as `grapgql_jwt` implementation, with standard output."
type RefreshToken {
    errors: ExpectedErrorType
    payload: GenericScalar
    refreshToken: String
    success: Boolean
    token: String
}

"""

Register user with fields defined in the settings.

If the email field of the user model is part of the
registration fields (default), check if there is
no user with that email or as a secondary email.

If it exists, it does not register the user,
even if the email field is not defined as unique
(default of the default django user model).

When creating the user, it also creates a `UserStatus`
related to that user, making it possible to track
if the user is archived, verified and has a secondary
email.

Send account verification email.

If allowed to not verified users login, return token.
"""
type Register {
    errors: ExpectedErrorType
    refreshToken: String
    success: Boolean
    token: String
}

"""

Sends activation email.

It is called resend because theoretically
the first activation email was sent when
the user registered.

If there is no user with the requested email,
a successful response is returned.
"""
type ResendActivationEmail {
    errors: ExpectedErrorType
    success: Boolean
}

"Same as `grapgql_jwt` implementation, with standard output."
type RevokeToken {
    errors: ExpectedErrorType
    revoked: Int
    success: Boolean
}

"""

Send password reset email.

For non verified users, send an activation
email instead.

Accepts both primary and secondary email.

If there is no user with the requested email,
a successful response is returned.
"""
type SendPasswordResetEmail {
    errors: ExpectedErrorType
    success: Boolean
}

"""

Send activation to secondary email.

User must be verified and confirm password.
"""
type SendSecondaryEmailActivation {
    errors: ExpectedErrorType
    success: Boolean
}

type StatisticMutationPayload {
    clientMutationId: String
    errors: [ErrorType]
    questionStatistic: QuestionStatisticNode
    statistic: QuestionStatisticNode
}

"""

Swap between primary and secondary emails.

Require password confirmation.
"""
type SwapEmails {
    errors: ExpectedErrorType
    success: Boolean
}

"""

Update user model fields, defined on settings.

User must be verified.
"""
type UpdateAccount {
    errors: ExpectedErrorType
    success: Boolean
}

type UpdateCardCoursePayload {
    clientMutationId: String
    course: CardCourseNode
}

type UpdateQuestionSequencePayload {
    clientMutationId: String
    sequence: QuestionSequenceNode
}

type UserNode implements Node {
    answerSet: [AnswerNode!]!
    archived: Boolean
    cardSet: [CardNode!]!
    cardauthorSet: [CardAuthorNode!]!
    cardcourseSet: [CardCourseNode!]!
    cardsubthemeSet: [CardSubThemeNode!]!
    cardthemeSet: [CardThemeNode!]!
    dateJoined: DateTime!
    email: String!
    firstName: String!
    globalcardthemeSet: [GlobalCardThemeNode!]!
    "The ID of the object."
    id: ID!
    "Designates whether this user should be treated as active. Unselect this instead of deleting accounts."
    isActive: Boolean!
    "Designates whether the user can log into this admin site."
    isStaff: Boolean!
    lastLogin: DateTime
    lastName: String!
    pk: Int
    questionSet: [QuestionNode!]!
    questionauthorSet: [QuestionAuthorNode!]!
    questionsequenceSet: [QuestionSequenceNode!]!
    questionthemesSet: [QuestionThemesNode!]!
    secondaryEmail: String
    userAccessLevel: CustomUserUserAccessLevel!
    "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."
    username: String!
    verified: Boolean
}

type UserNodeConnection {
    "Contains the nodes in this connection."
    edges: [UserNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `UserNode` and its cursor."
type UserNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: UserNode
}

"""

Verify user account.

Receive the token that was sent by email.
If the token is valid, make the user verified
by making the `user.status.verified` field true.
"""
type VerifyAccount {
    errors: ExpectedErrorType
    success: Boolean
}

"""

Verify user secondary email.

Receive the token that was sent by email.
User is already verified when using this mutation.

If the token is valid, add the secondary email
to `user.status.secondary_email` field.

Note that until the secondary email is verified,
it has not been saved anywhere beyond the token,
so it can still be used to create a new account.
After being verified, it will no longer be available.
"""
type VerifySecondaryEmail {
    errors: ExpectedErrorType
    success: Boolean
}

"Same as `grapgql_jwt` implementation, with standard output."
type VerifyToken {
    errors: ExpectedErrorType
    payload: GenericScalar
    success: Boolean
}

"An enumeration."
enum AnswerHardLevelOfAnswer {
    "Очевидный"
    EASY
    "Каверзный"
    HARD
    "Обычный"
    MEDIUM
}

"An enumeration."
enum CardCardContentType {
    "youtube видео"
    A_0
    "ссылка на внешний ресурс"
    A_1
    "просто изображение"
    A_2
}

"An enumeration."
enum CustomUserUserAccessLevel {
    "Admin"
    ADMIN
    "Student"
    STUDENT
    "Teacher"
    TEACHER
}

input AnswerMutationInput {
    checkQueue: Int!
    clientMutationId: String
    createdBy: ID!
    hardLevelOfAnswer: String!
    helpTextv1: String
    helpTextv2: String
    helpTextv3: String
    id: ID
    isDeleted: Boolean
    isInvisible: Boolean
    isRequired: Boolean
    isTrue: Boolean
    question: ID!
    text: String
    videoUrl: String
}

input CardAuthorMutationInput {
    clientMutationId: String
    createdBy: ID!
    id: ID
    name: String!
}

input CardMutationInput {
    additionalText: String
    author: [ID]
    cardContentType: String!
    clientMutationId: String
    createdBy: ID!
    id: ID
    isCardUseAdditionalText: Boolean
    isCardUseMainContent: Boolean
    isCardUseMainText: Boolean
    isCardUseTestBeforeCard: Boolean
    isCardUseTestInCard: Boolean
    siteUrl: String
    subTheme: [ID]
    testBeforeCard: ID
    testInCard: ID
    text: String
    title: String!
    videoUrl: String
}

input CardSubThemeMutationInput {
    clientMutationId: String
    createdBy: ID!
    id: ID
    name: String!
    theme: ID
}

input CardThemeMutationInput {
    clientMutationId: String
    createdBy: ID!
    globalTheme: ID
    id: ID
    name: String!
}

input CreateCardCourseInput {
    clientMutationId: String
    courseData: GenericScalar
    createdBy: ID
}

input CreateDetailQuestionStatisticInput {
    clientMutationId: String
    isLogin: Boolean
    question: ID!
    statistic: GenericScalar
    userName: String
}

input CreateQuestionSequenceInput {
    clientMutationId: String
    createdBy: ID
    sequenceData: GenericScalar
}

input GlobalCardThemeMutationInput {
    clientMutationId: String
    createdBy: ID!
    id: ID
    name: String!
}

input QuestionAuthorMutationInput {
    clientMutationId: String
    createdBy: ID!
    id: ID
    name: String!
}

input QuestionMutationInput {
    author: [ID]
    clientMutationId: String
    createdBy: ID!
    id: ID
    isImageQuestion: Boolean
    numberOfShowingAnswers: Int
    text: String!
    theme: [ID]
    videoUrl: String
}

input QuestionThemesMutationInput {
    clientMutationId: String
    createdBy: ID!
    description: String
    id: ID
    name: String!
}

input StatisticMutationInput {
    clientMutationId: String
    id: ID
    numberOfPasses: Int!
    question: ID!
    sumOfAllAttempts: Int!
}

input UpdateCardCourseInput {
    clientMutationId: String
    courseData: GenericScalar
    courseId: ID!
    name: String
}

input UpdateQuestionSequenceInput {
    clientMutationId: String
    description: String
    name: String
    sequenceData: GenericScalar
    sequenceId: ID!
}


"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
Errors messages and codes mapped to
fields or non fields errors.
Example:
{
field_name: [
{
"message": "error message",
"code": "error_code"
}
],
other_field: [
{
"message": "error message",
"code": "error_code"
}
],
nonFieldErrors: [
{
"message": "error message",
"code": "error_code"
}
]
}
"""
scalar ExpectedErrorType